
\section{Plugin}
In order to improve the deployment and usage of the refactoring tool a plugin
for DrRacket was created.
DrRacket has several advantages and the plugin support is another one, because
it allows a simple integration with DrRacket itself a simple managing interface.
Another advantage is the incorporation with git. A plugin can be a link for a git
repository and because of that it becomes simple to keep the refactoring tool up to date.

However, the main reason to create a plugin is to become independent from DrRacket
internal changes.
\section{FrameWork}
Refactoring tools have similar architecture with each other, and such similarities
create the possibility of reusing some modules. And instead of creating every
module of the refactoring tool if there was already ready to use modules refactoring
tool development would become a lot faster.
Since we desire to create a refactoring tool targeted to beginner programmers with
specialized refactoring operations and we want such refactoring tool to be available
for several languages used in introductory courses around the world and not just for
Racket programming language.
Creating a framework for refactoring tools increases both the speed and the simplicity (??)
of creating a refactoring tool and therefore it is able to provide the features already available
for one refactoring tool in the others without extra effort. Such features highly improve
the usefulness of the refactoring tool, for example the highlight of possible refactoring
operations, the previewing of the result and support to detect duplicated code.


 %[TODO Explain META-LANGUAGE]
 Impementing the framework in Racket combined with the implmented languages for DrRacket is what does the trick,
 since we use the implemetnation as a meta-language which creates syntax objects as the ones used to represent the racket language.
  Being the meta-language a language that are
 composed only by syntax elements is a huge advantage to compute effortless new
 refactoring operations for new languages when compared with the necessary effort to create
 the refactoring operations directly for that language.

Ideally we should only have refactoring operations for the meta-language which represents
all languages. And then specialized pretty printers to output the changes in the
desireble language.
However, since we instead of having a general representation that can represent all the languages
supported we have the languages represented in Racket's syntax objects we can not do that.

We indeed have a meta-language that abstracts all the supported languages and
we have trully language independent refactoring operations. However, it is only
for a small set of refactoring opeartions, the more simple ones. We did it like
this because we would lose some of the possible refactoring operations or we would
have to have a lot of concerns. And since we have a restrict amount of time, having
a meta-language that have language-independent refactoring operations combined
with the "semi-meta-languages" that have similar refactoring operations but
language dependent and therefore more specialized.

With this we do not have a language-independent framework. However we have a framework
for refactoring operations, even tough that is more aimed at dynamic and functional languages.
Framework architecture.%FIXME this is super weird
\begin{figure}[h]
\includegraphics[width=8cm]{../framework-arch2.png}
\label{fig:framework}
\end{figure}

As it is described in Figure~\ref{fig:framework} we have a module that provides
independent refactoring operations and a module for each language supported that
have specialized refactoring operations. We also have pretty-printing modules for
each supported language.

We already have refactoring operations for Racket, Python, and Processing. We choose
this languages because they are already implemented in Racket and they are both
often used by beginners.


\subsection{Statement based languages}
This Framework was build with a base of expression based languages. The flow of
the program is needed to decide whether or not a refactoring can be correctly done
or even to decide where and how many returns a function needs. However this could
be minimized with a PDG (program depedence graph) that has the control flow information
needed to compute correct refactorings.

\subsection{Language Independent refactoring operations}
Creating a fully language independent refactoring tool is difficult since programming
languages differ from each other, even some operations that seams to be equal can
have small differences. %TODO give an example.
However, for simple refactoring opeartions that not require much program semantics,
such as refactoring operations that focus only in the syntax.
With this it is possible to have only the refactoring operation in the meta-language
and use it to refactor code in the implemented languages.
\subsection{Language dependent refactoring operations}
It is necessary to have refactoring operations that are language dependent, since
some refactoring operatons have som particularties for each supported language.
Having specific refactoring operations, language dependent ones, it is possible
to implement some useful refactoring operations in a simple way that otherwise would
be too complex.
\section{Features}
how easy it is to add new refactoring operations and languages
The framework it is simply to use, it is only necessary to have a specification file
of each refactoring operation.
That file must have a function that receives two arguments,
one is the AST of the program and the other is the def-use-relation.
This information makes it possible to have several refactoring operations that help
the programmer.
what was "reused"
everything except the refactoring operations itself.
the advantages of that
This Framework makes it easier to implement refactoring operations for dynamic languages,
with only the catch that they have to be implemented for DrRacket. Helping minimizing
the problem of the difficulty and lacking of refactoring operations for dynamic languages.
(for at least every language implemented for DrRacket)
\section{Tool Maintenance} %Framework maintenance!
%Developer Point of view
%%%% Nor for the paper tough %%%%
%%automatic might help save work when the user nows what exactly the tool will do.

%This feature combined with the automatic suggesting is a huge help to do the
%evaluation of this refactoring tool and to use in battery tests.


A refactoring tool is a quite complex piece of software and therefore requires maintenance.
Automatic testing is used in general by developers to ensure that the software
is bug free for those test cases.
By having a way to automatically perform all the refactoring operations found,
the developer of a refactoring tool can test and ensure if the changes made did not introduce
bugs in other refactoring operations of the refactoring tool.
One way to automatic test the refactoring operations is to apply every refactoring
operations possible to a piece of code. By having this possibility it is simpler
to the developer to create specific test cases that simplify tool maintenance.
In order to do this it is necessary to correctly identify all the possible refactoring
operations in one piece of code. Such operation is already implemented in the refactoring
tool, the automatic suggesting.
Therefore the remaining part of the algorithm is to apply all of those operations.
The trick part is  that every refactoring operation changes the AST, so after
applying one refactoring operation it is necessary to recompute the program AST.
By changing the AST the possible refactoring operations applicable also might change,
so it is necessary to recompute the AST.

%First the automated refactoring displays all the possible refactoring found thus making it easier
%to detect the refactoring operations in projects.
%It makes it easier to evaluate the need to do the refactoring and to evaluate
%if the refactoring tool (frameowork) is working correctly.
%Second the automatic refactoring makes it easier to test if the refactoring operations are correct (**** for a limited test cases ****)
%This is possible by running the test cases of the program before any refactoring.
%Then using automatic refactoring in the program that applies all the refactoring that the tool finds.
%And finally by running again the test cases of the program.
%After testing it with several (or huge) programs if every test passes (or the exact same tests, because refactoring operations should not fix bugs)
%we can consider that the refactoring operations are correct.
\section{Analysis}

\section{Conclusion}
\section{Future Work}
Add a PDG to the framework.
