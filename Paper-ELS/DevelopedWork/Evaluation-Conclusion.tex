\lstdefinestyle{racket}{
  language=Lisp,
  basicstyle=\tt\scriptsize,
  columns=fullflexible,
  commentstyle=\color{Gray},
  keywordstyle=\color{Blue},
  identifierstyle=\color{Blue},
  stringstyle=\color{Green},
  numbers=left,
  numberstyle=\small\tt,
  frame=lines,
}

\lstdefinestyle{racket}{
  language=Lisp,
  basicstyle=\tt\scriptsize,
  columns=fullflexible,
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  identifierstyle=\color{black},
  stringstyle=\color{green},
  numbers=left,
  numberstyle=\small\tt,
  frame=none,
  morekeywords={define,if,else,cond},
  literate={% replace strings with symbols
    {lambda}{{$\lambda$}}{1}
  },
}

\section{Evaluation}
In this section we present some code examples written by beginner programmers
in their final project of an introductory course and their possible improvements
using the refactoring operations available in our refactoring tool.
The examples show the usage of some of the refactoring operations previous presented
and here is explained the motivation for their existence.

\lstset{style=racket}


The first example is a very typical error made beginner programmers.
\begin{lstlisting}
  (if (>= n_plays 35)
        #T
        #F)
\end{lstlisting}
It is rather a simple refactoring operation, but nevertheless it improves the code.
%if after , caption=Refactored If expression
\begin{lstlisting}
  (>= n_plays 35)
\end{lstlisting}

%and before , caption=And expression
The next example is related with the conditional expressions, namely the {\tt and}
or {\tt or} expressions. We decided to choose the {\tt and} expression to exemplify a
rather typical usage of this expression.
\begin{lstlisting}
(and
  (and
   (eq? #t (correct-moviment? player play))
   (eq? #t (player-piece? player play)))
  (and
   (eq? #t (empty-destination? play))
   (eq? #t (empty-start? play))))
\end{lstlisting}


%and after
Transforming the code by removing the redundant {\tt and} expression makes the code
cleaner and simpler to understand.
\begin{lstlisting}
(and  (eq? #t (correct-moviment? player play))
      (eq? #t (player-piece? player play))
      (eq? #t (empty-destination? play))
      (eq? #t (empty-start? play)))
\end{lstlisting}

However, this code could still be improved, the {\tt (eq? \#t ?x)} is a redundant way
of simple writing {\tt ?x}.
\begin{lstlisting}
(and  (correct-moviment? player play)
      (player-piece? player play)
      (empty-destination? play)
      (empty-start? play))
\end{lstlisting}


While a student is still learning and experiencing it is easier to confuse whether
or not an expression needs the {\tt begin} expression or not.
The {\tt when}, {\tt cond} and {\tt let} expressions have a implicit {\tt begin} expression and
as a result it is not necessary to add the {\tt begin} expression.
Moreover, sometimes they still kept the {\tt begin} keyword because often use error and trial approach
in writing code.
Our refactoring tool checks for those mistakes and corrects them.
%let with begin before, Chose a better example
\begin{lstlisting}
  (if (odd? line-value)
      (let ((internal-column (sub1 (/ column 2))))
        (begin
          (if (integer? internal-column)
              internal-column
              #f)))
      (let ((internal-column (/ (sub1 column) 2)))
        (begin
          (if (integer? internal-column)
              internal-column
              #f))))
\end{lstlisting}
%let with begin after
It is a simple refactoring operation and it does not have a big impact, however
it makes the code clear and helps the beginner programmer to learn that a {\tt let}
does not need a {\tt begin}.
\begin{lstlisting}
  (if (odd? line-value)
        (let ((internal-column (sub1 (/ column 2))))
          (or (integer? internal-column)
              internal-column))
        (let ((internal-column (/ (sub1 column) 2)))
          (or (integer? internal-column)
              internal-column)))
\end{lstlisting}


The next example shows a nested {\tt if}. Nested {\tt if}s are
 difficult to understand, error prone, and a debugging nightmare.
It is much simpler to have a {\tt cond} expression.
In addition, every true branch of this nested if contains {\tt if} expressions that are
or expressions and by refactoring those {\tt if} expressions to {\tt or}s it makes the code
simpler to understand.
%if to cond before
\begin{lstlisting}
  (define (search-aux? board line column piece)
    (if
      (> column 8)
      #f
      (if
        (= line 1)
        (if
          (eq? (house-board
               board 1 column) piece)
          #t
          (search-aux? board line
            (+ 2 column) piece))
        (if (= line 2)
          (if
            (eq? (house-board
              board 2 column) piece)
            #t
            (search-aux? board line
              (+ 2 column) piece))
          (if (= line 3)
            (if
              (eq? (house-board
                board 3 column) piece)
              #t
              (search-aux? board line
                (+ 2 column) piece))
            (if (= line 4)
              (if
                (eq? (house-board
                  board 4 column) piece)
                #t
                (search-aux? board line
                  (+ 2 column) piece))
              (if (= line 5)
                (if
                  (eq? (house-board
                    board 5 column) piece)
                  #t
                  (search-aux? board line
                    (+ 2 column) piece))
                (if (= line 6)
                  (if (eq? (house-board
                        board 6 column) piece)
                    #t
                    (search-aux? board line
                           (+ 2 column) piece))
                  (if (= line 7)
                    (if (eq? (house-board
                          board 7 column) piece)
                      #t
                      (search-aux? board line
                        (+ 2 column) piece))
                    (if (= line 8)
                      (if (eq? (house-board
                        board 8 column) piece)
                        #t
                       (search-aux? board
                         line (+ 2 column) piece))
                    null))))))))))
\end{lstlisting}
%if to cond after

This transformations drastically reduced the lines of code, from 59 to 28 that accounts
for a 52\% reduction of the lines of code.

\begin{lstlisting}
  (define (search-aux? board line column piece)
   (cond
   [(> column 8) #f]
   [(= line 1)
    (or (eq? (house-board board 1 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 2)
    (or (eq? (house-board board 2 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 3)
    (or (eq? (house-board board 3 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 4)
    (or (eq? (house-board board 4 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 5)
    (or (eq? (house-board board 5 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 6)
    (or (eq? (house-board board 6 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 7)
    (or (eq? (house-board board 7 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [(= line 8)
    (or (eq? (house-board board 8 column) piece)
          (search-aux? board line (+ 2 column) piece))]
   [else null]))
\end{lstlisting}

However, this code could still be further improved by refactoring it into a {\tt case}. \\


The examples presented above appear repeatedly in almost every code submission of this final project supporting the need to
proper support to beginner programmers.
%if the users had a refactoring tool that highlighted their code in areas that
%could be improved, they probably would not have this kind of code.


\section{Conclusion}
A refactoring tool designed for beginner programmers would benefit them
by providing a tool to restructure the programs and improve what more knowledgeable programmers call ``poor style,''
``bad smells,'' etc.
In order to help those users it is necessary to be usable from a pedagogical IDE,
to inform the programmer of the presence of the typical mistakes made by beginners, and
to correctly apply refactoring operations preserving semantics.

Our solution tries to help those users to improve their programs by using the AST of
the program and the def-use-relations to create refactoring operations that do not
change the program's semantics. This structure is then used to analyze the code
to detect typical mistakes using automatic suggestions and correct them using the
refactoring operations provided.


There are still some improvements that we consider important for the user.
Firstly, the detection of duplicated code is still very naive and improving to understand if
two variables represent the same even if the names are different or even if the
 order of some commutative expressions is not the same would make a huge improvement
 on the automatic suggestion.
Then it is possible to improve the automatic suggestion of refactoring operations by
having different colors for different types of refactoring operations.
With a lower intensity for low "priority" refactoring operations and a high intensity
for higher "priority". Thus giving the user a better knowledge of what is a better
way to solve a problem or what is a strongly recommendation to change the code.
Lastly it would be interesting to detect when a developer is refactoring in order to help the developer finish the
refactoring by doing it automatically \cite{ge2012reconciling}.
