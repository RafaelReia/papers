

\lstdefinestyle{racket}{
  language=Lisp,
  basicstyle=\tt\small,
  columns=fullflexible,
  commentstyle=\color{Gray},
  keywordstyle=\color{Blue},
  identifierstyle=\color{Blue},
  stringstyle=\color{Green},
  numbers=left,
  numberstyle=\small\tt,
  frame=lines,
}


\section{Evaluation}
In this section we present some code examples written by beginner programmers
in their final project of an introductory course and their possible improvements
using the refactoring operations available in our refactoring tool.
The examples show the usage of some of the refactoring operations previous presented
and here is explained the motivation for their existence.
This code mistakes appear repeatedly in almost every project supporting the need to
this kind of refactoring.
\lstset{style=racket}


The first example is a very typical error made beginner programmers.
Almost every project has one or more piece of code similar to this one
\begin{lstlisting}[basicstyle=\ttfamily]
  (if (>= n_plays 35)
        #T
        #F)
\end{lstlisting}
It is rather a simple refactoring operation, but nevertheless it improves the code.
%if after , caption="Refactored If expression"
\begin{lstlisting}[basicstyle=\ttfamily]
  (>= n_plays 35)
\end{lstlisting}

%and before , caption="And expression"
The next example is related with the conditional expressions, namely the {\tt and}
or {\tt or} expressions. We decided to choose the {\tt and} expression to exemplify a
rather typical usage of this expression.
\begin{lstlisting}[basicstyle=\ttfamily]
(and
  (and
   (eq? #t (correct-moviment? player play))
   (eq? #t (player-piece? player play)))
  (and
   (eq? #t (empty-destination? play))
   (eq? #t (empty-start? play))))
\end{lstlisting}


%and after
Transforming the code by removing the redundant {\tt and} expression the code becomes
cleaner and simpler to understand. Needless to say it is still a rather simpler
refactoring operation.
\begin{lstlisting}[basicstyle=\ttfamily]
(and  (eq? #t (correct-moviment? player play))
      (eq? #t (player-piece? player play))
      (eq? #t (empty-destination? play))
      (eq? #t (empty-start? play)))
\end{lstlisting}

However, this code could still be improved, the {\tt (eq? \#t ?x)} is a redundant way
of simple writing {\tt ?x}.
%remove eq
\begin{lstlisting}[basicstyle=\ttfamily]
(and  (correct-moviment? player play)
      (player-piece? player play)
      (empty-destination? play)
      (empty-start? play))
\end{lstlisting}


While a student is still learning and experiencing it is easier to confuse whether
or not an expression needs the the "begin" expression or not.
The {\tt when}, {\tt cond} and {\tt let} expressions have a implicit {\tt begin} expression and
as a result it is not necessary to add the {\tt begin} expression.
Our refactoring tool checks for those mistakes and corrects them.
%let with begin before, Chose a better example
\begin{lstlisting}[basicstyle=\ttfamily]
  (if (odd? line-value)
      (begin
        (let ((internal-column (sub1 (/ column 2))))
          (if (integer? internal-column)
              internal-column
              #f)))
      (begin
        (let ((internal-column (/ (sub1 column) 2)))
          (if (integer? internal-column)
              internal-column
              #f))))
\end{lstlisting}
%let with begin after
It is a simple refactoring operation and it does not have a big impact, however
it makes the code clear and helps the beginner programmer to learn that a {\tt let}
does not need a {\tt begin}.
\begin{lstlisting}[basicstyle=\ttfamily]
  (if (odd? line-value)
        (let ((internal-column (sub1 (/ column 2))))
          (or (integer? internal-column)
              internal-column))
        (let ((internal-column (/ (sub1 column) 2)))
          (or (integer? internal-column)
              internal-column)))
\end{lstlisting}


The next example shows nested if expressions. This kind of nested if expressions
is difficult to understand, error prone, and is a debugging nightmare.
It is much simpler to have a {\tt cond} expression.
In addition, every true branch of this nested if contains if expressions that are
or expressions and by refactoring those if expressions to ors it makes the code
simpler to understand.
%if to cond before
\begin{lstlisting}[basicstyle=\ttfamily]
  (define (search-aux? board line column piece)
   (if
    (> column 8)
    #f
    (if
     (= line 1)
     (if
      (eq? (house-board
            board 1 column) piece)
      #t
      (search-aux? board line
                      (+ 2 column) piece))
     (if (= line 2)
      (if
       (eq? (house-board
              board 2 column) piece)
       #t
       (search-aux? board line
                      (+ 2 column) piece))
      (if (= line 3)
       (if
        (eq? (house-board
                board 3 column) piece)
        #t
        (search-aux? board line
                      (+ 2 column) piece))
       (if (= line 4)
        (if
         (eq? (house-board
                  board 4 column) piece)
         #t
         (search-aux? board line
                        (+ 2 column) piece))
        (if (= line 5)
         (if
          (eq? (house-board
                board 5 column) piece)
          #t
          (search-aux? board line
                          (+ 2 column) piece))
         (if (= line 6)
          (if (eq? (house-board
                     board 6 column) piece)
           #t
           (search-aux? board line
                           (+ 2 column) piece))
          (if (= line 7)
           (if (eq? (house-board
                      board 7 column) piece)
            #t
            (search-aux? board line
                            (+ 2 column) piece))
           (if (= line 8)
            (if (eq? (house-board
                       board 8 column) piece)
             #t
             (search-aux? board
                line (+ 2 column) piece))
            null))))))))))
\end{lstlisting}
%if to cond after

This transformation consists in an aggregation of two refactoring operations, {\tt if-to-cond} and {\tt if-to-or}.
The {\tt if-to-cond} has the biggest impact and reduces drastically the number of lines.
In addition the if-to-or helps to make the code clearer.
It drastically reduced the lines of code, from 59 to 28 that accounts
for a 52\% reduction of the lines of code.

\begin{lstlisting}[basicstyle=\ttfamily]
  (define (search-aux? board line column piece)
   (cond
   [(> column 8) #f]
   [(= line 1)
    (or (eq? (house-board board 1 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 2)
    (or (eq? (house-board board 2 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 3)
    (or (eq? (house-board board 3 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 4)
    (or (eq? (house-board board 4 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 5)
    (or (eq? (house-board board 5 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 6)
    (or (eq? (house-board board 6 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 7)
    (or (eq? (house-board board 7 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [(= line 8)
    (or (eq? (house-board board 8 column) piece)
      (search-aux? board line (+ 2 column) piece))]
   [else null]))
\end{lstlisting}



%extract function before

%extract function after

%These are some real examples of pieces of code made for beginners, in the course
%project of the programming introductory course.


Beginners often use error and trial approach in code writing which led %FIXME
to peaces of code like the presented above.
If the users had a refactoring tool that highlighted their code in areas that
could be improved, they probably would not have this kind of code.


\section{Conclusion}

%growing importance of programing.
%growing importance support tools for beginners
%lack of refactoring tools for beginners
%the use that the beginners might use


The growing interest in programming as a skill combined with the need of areas
non related with any computation field creating the need to improve the support
given to the beginner programmer. %FIXME
Therefore a refactoring tool designed for beginners in a pedagogical environment such as DrRacket %FIXME IMPROVE
 would benefit those users as it would help them in their first contact with a
 refactoring tool and improve their code safely. %suggest the refactorings?
%this combined/composition with the importance increase of programming

Our solution tries to help those users to improve their programs and to facilitate
the first contact with a refactoring tool.
By having a refactoring tool designed for beginners in a pedagogical environment
that suggests possible refactoring operations.

We also shown the practicability of the refactoring tool with simple refactoring operations
that improved safely the beginners code.

%The second one is the crescent importance of the support given to beginner users %FIXME
%that made JetBrains, a company known for their professional IDEs, to make PyCharm - edu
% an IDE that is aimed for beginners and it also has incorporated a refactoring tool.
%Lastly the refactoring tools concern with professionals leaves the beginner
% user helpless.
% A refactoring tool aimed for beginners would help them to safely improve %FIXME!!!!!
% their code while giving those users the first contact with a refactoring tool.

%\section{Future work}
There are some improvements that we consider important and in the future it would  %FIXME
be a huge improvement detecting when a developer is refactoring in order to help the developer finish the
refactoring by doing it automatically \cite{ge2012reconciling}.
%This would be important specially for beginners that would help them finishing
%the transformations safely while teaching them refactoring operations. %FIXME yup...

%Our automatic detecting of duplicated code is still very naive.
The detection of duplicated code is still very naive and improving to understand if
two variables represent the same even if the names are different or even if the
 order of some commutative expressions is not the same would make a huge improvement
 on the automatic suggestion.

%Because the goal of the refactoring tool is to let beginners have the first touch
%with refactoring tools, having a good preview is important to show the user what
%the refactoring operation does.
%Improving the existing preview and changing from the menu to the code directly
%would be a great improvement to this refactoring tool.

%Improve the Preview of the refactoring operations.

%Improving automatic detection %TODO add code smells
It is possible to improve the automatic suggestion of refactoring operations by
having different colors for different types of refactoring operations.
This would let the user know what refactoring is being suggested without having to
select the area.
Another improvement that could be made is the color intensity of the suggestion.
With a lower intensity for low "priority" refactoring operations and a high intensity
for higher "priority". Thus giving the user a better knowledge of what is a better
way to solve a problem or what is a strongly recommendation to change the code.
