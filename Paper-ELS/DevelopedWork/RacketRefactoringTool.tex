%\section{Racket Refactoring Tool}
%This section explains the decisions made in order to make this refactoring tool.

\section{Architecture}
%Refactoring Tool work flow: (add a brief explanation of what does )
The Refactoring tool uses mainly two sources of information, the def-use-relations and
the AST of the program.

The def-use-relations are visually represented in a form of Arrows in DrRacket,
that information is especially relevant for refactoring operations such as Extrac-Function,
Add-Prefix, Organize-Imports, etc.

The AST is represented by the s-expressions that compose the racket program. In
Racket everything is a syntax-expression and therefore accessing the list (tree)
of the syntax-expressions has all the information that a normal AST provides.


[INSERT IMAGE HERE]

%The AST is acquired after using the check-syntax button. It was intended to be
%acquired automatically, because DrRacket has an online check syntax, but it was
%not possible. After that it cleans the AST removing information that is not
%necessary, at least for now, for the refactoring operations. When the AST is cleaned it
%passes the exact part of the AST that was selected. And tries to match rules,
%using syntax-parse against that syntax.

\subsection{Def-Use-Relations}

DrRacket already uses the def-use-relations in the system that are visually
represented by arrows in the GUI.
The def-use-relations is computed by the online-compiler that runs in the background
However it is only processed when a program is syntactically correct. (e.g. if
a program has syntax errors there are no arrows produced in DrRacket)

%The information is computed in the online-comp.rkt that is where expands
%and computes the information needed to know the def-use-relations and whether
%the program is syntactically correct.
%There is an online expansion monitor that calls the online-comp, the online-comp
%then expands the program (to the expanded program) and does a trace to get the
%information needed for the arrows (def-use-relations).
%Afterwards it sends back that information to the caller of the online-comp to do
%the replay of the trace did by the compile comp and to process the information
%about the arrows.

\subsubsection{Def-Use-Relations utility}
Def-Use-Relations are important in order to produce correct refactoring operations
because they can be used to check whether or not there will be a duplicated name
or even to compute the arguments of a function to be extracted.


\subsection{Syntax Expressions}
The Syntax expressions (s-exp) list are already being produced and used by the
Racket language and in DrRacket. They represent the program and are computed in
order to provide error information to the user.
DrRacket already provides functions in order to create s-exp lists and uses some of those
functions in the online check syntax and in the check syntax button callback.

[insert images here explaining that]


\subsubsection{Syntax Expression tree forms}
DrRacket provides functions to compute the s-exp list in two different formats.
One format is the expanded program, this format is used by the Check Syntax and
the online check syntax, and computes the program expanded.
The other format is the non-expanded program and computes the program unexpanded.

The expanded program has the macros expanded and the identifier information computed,
however it is harder to extract the relevant information when compared with the
non expanded program.
%Racket has two forms of syntax tree. An expanded form, with the macros expanded
%and a non expanded form that is after a read-syntax without the macros expanded.

For example, the following program is represented in the expanded program,
and in the non expanded program.
\begin{lstlisting}[caption="example"]
#lang racket
(if (= (+ 1 2) 1)
      #f
      #t)
\end{lstlisting}

\begin{lstlisting}[caption="Syntax from Example"]
#<syntax:3:0 (if (< 1 2) #t #f)>
\end{lstlisting}

\begin{lstlisting}[caption="Expanded Syntax from example"]
#<syntax:1:0 (module anonymous-module racket
  (#%module-begin (module configure-runtime
    (quote #%kernel)#%module-begin
      (#%require racket/runtime-config)
        (#%app configure (quote #f))))
          (#%app call-with-values (lambda ()
            (if (#%app < (quote 1) (quote 2))
              (quote #t) (quote #f))) print-values)))>
\end{lstlisting}

%Expanded Program Vs Not expanded Program
%Talk about difficulty, durability, Python (other languages)

%[Only in the expanded form] (and) is treated like an if which is bad and give problems
%The rest tends to work.
%testing:
%(if (= (+ 1 2) 1) \#f \#t) to (not (= (+ 1 2) 1))

The expanded program transforms the "and", "or", "when" and "unless" forms into
ifs and that makes refactoring operations harder to implement.

Racket adds internal representation information to the expanded-program which for
most refactoring operations are not needed.

However, the expanded program has important information regarding the binding
information that is not available in the non-expanded form and is rather useful
to detect if two identifiers refer to the same binding.
%TODO check; It also contains information where a program returns or not. TODO CHECK!
In addition to that, the expanded program has a format that is likely to change
in the future because Racket is an evolving language and the expanded form is a
low level and internal form of representation of the program in Racket.

All those combined make it desirable to use the non expanded form for the refactoring
operations as much as possible and use the expanded form only for the necessary
operations.


%Sub Cap Code with Macros The Problem
Macros usage could make the refactoring operations incorrect by modifying the
program behavior. This is not considered part of the scope of this refactoring
tool capabilities.
This is not considered part of the scope problem because this refactoring tool
is aimed at unexperienced programmers (that had one semester of programming classes)
 and those type of programmers do not use macros.

 If we intended to create a tool that supports macros the non expanded program
 is insufficient and the expanded program must be used. However there are no
 guarantees that would be enough to ensure the correctness of such refactoring
 operations due to the reflection capabilities of Racket.

%Dependency of Racket evolution
%Using the expanded program might simplify the refactoring for other languages,
%for example it has a literal that says when the program returns in python, and
%racket does not have it. In the expanded form there is syntax that explicitly says
%where the program returns.

%In the future it is possible to create a tool that uses both program expansions,
%making it possible to have macros and the relation with other languages for the
%more difficult problems and using the non expanded program for the simple cases.

\subsection{Code-walker} % [TODO explain better]
The code-walker is used to parse the syntax tree represented by a syntax elements
that is a list of s-exp in racket. %TODO check this.
A syntax element can contain either a symbol, a syntax-pair, a datum (number, boolean or string)
or an empty list. %might contain other stuff but never got it, not relevant?
While a syntax-pair is a pair containing a syntax object as it first element and
a syntax pair, a syntax element or an empty list as the second argument.
Each syntax-object has information about the line where they are defined and this
information is used by the code-walker to find the correct elements.

%A syntax object combines a simpler Racket value, such as a symbol or pair, with a scope set at each phase level,
%source-location information, syntax properties, and tamper status. In particular, an identifier is represented as
%a syntax object that combines a symbol with scope sets and other information. The lexical information of a syntax
%object is its scope set combined with the portion of the global table of bindings that is relevant to the syntax objectâ€™s set of scopes.

Most of the time using the code-walker we are searching for a specific syntax element
and we use the location information contained in the syntax-object in order to
skip the syntax blocks that are before the syntax element wanted in the first place.

The Code-walker is a core part of the refactoring tool ensuring that the selected
syntax is correctly fed to the refactoring operations.

%the way that the code-walker guarantees that goes to every important part of the
%tree is by having a "pointer" to the current selected syntax element, and have
%a stack that contains the remaining code to analyze.
%Because of this structure it is necessary to have a stack in order to search
%the tree correctly and in the best way possible.
%Because Most of the time we are searching for a specific syntax element (e.g function,
%define, etc, because everything is a syntax element in Racket) and using this we
%can skip uninteresting syntax in order to get to the syntax that we want to use.


%%%%%% Writing Part of the Refactoring/refactoring rule
\section{Writting}
\subsection{Syntax-Parse}
%Syntax-Parse Utility
The Syntax-Parse function provided by Racket is rather useful for the refactoring
operations regarding mainly syntax information.
It has a wide range of options to help matching the correct syntax it also have
backtracking. With Backtracking it is possible to have several rules to be match
in the same syntax parser which helps to create more sophisticated rules.

\subsubsection{Literal vs Datum-literal}
One of the options in the syntax-parse is to specify if an element is a literal.
The #:literals option specifies identifiers that should be treated as literals
rather than pattern variables. This option helps to ensure that a refactoring
operation made is targeted only to the correct elements of the language. There is
also another option that is very similar to the literals know as datum-literals.
Datum-literals match symbols instead of an identifier and can be rather useful as
the literals option because it provides a wider range of options.

However because of an unknown bug the literals option only works with the expanded-program
and we are limited to use the datum-literals option. This could possible create
incorrect refactoring transformations when the user renames the literals of the
language. e.g(renaming the if, cond, let, defines, syntax, when, unless, etc)

\subsection{Pretty Printing}

Pretty Printing (E.g. Cond lets etc)
The racket makes it easy to modify syntax using the syntax-parse to transform the
AST into another AST.
In order to produce indented code we choose to use a pretty-printer already
incorporated in the language.
However this pretty-printer does not follow the convention in the cond clauses
should be surrounded by [] parenthesis. This is not considered a problem because
Racket supports both representations.
One possible solution is to use a different pretty-printer in
order to keep the language convention.
%Some syntax elements (s-expressions) lose some information about parenthesis.
%For example it is a convention that cond clauses should be surrounded by [] parenthesis
%but the syntax element does not store that kind of information.
%There are several pretty-printers developed for Racket and even the Racket language
%has one incorporated.
%The one already incorporated does not use the [ ] parenthesis, however racket
%supports both representations.



\section{Refactoring operations}

\subsection{semantic problems}
There are known semantic problems that might occur after doing a refactoring
operation.
One of those problem occurs when removing the and of the following example
(E.g. (and (< 1 (foo 2)) (< (foo 2) 3)) )
The refactoring transforms the code into this:
(< 1 (foo 2) 3)
This refactoring has semantic problems if the function "foo" has collateral effects.
And instead of applying those collateral effects twice it will only apply once therefore
changing the semantic of the program.

We still decided to keep this refactoring operation because for the vast majority
of the cases this does not change the semantic of the program and the solution
would limit too much this kind of refactoring. Because of the reflection capabilities
of racket we could only safely apply this refactoring when the arguments of the
"<" were datums (number, boolean or string).

\subsection{Extract Functions}
Extract function is an important refactoring operation that every refactoring tool
should have. However is not that simple to implement and there are some things to
take into account.
In order to extract a function it is necessary to compute the arguments needed
to the correct use of the function. While naming the new function it is an interesting
feature to check if that name is duplicate.
Then computing the body and replacing it by the call should be straightforward.
Another problem is where should the function be extracted to. A function can not
be defined in an expression, (e.g inside a let) but it could be defined in the top-level
or in any other level that is accessible from the top level.

e.g: When extracting the \'(+ 1 2) to a function where should it be defined?
Top-level? level-0 level-1 or in the current level, level-2?
\begin{lstlisting}[caption="Example"]
;;top-level
(define (level-0)
  (define (level-1)
    (define (level-2)
      (+ 1 2))
    (level-2))
  (level-1))
\end{lstlisting}

The fact is that is extremely difficult to know the answer to this question, and
we think that the best solution to this question is to let the user decide where
he want the function defined.


\subsubsection{Computing the arguments}
%In previous versions of the online-comp information about the type of arrows
%was available in the structure. However in the recent versions that type of
%information was removed.

%With the previous version of the online-comp the framework was computing the argument for the
%newly extracted function using the type information: "one of 'lexical, 'top-level, 'import".
In order to compute the arguments we have to know which variables are being define
inside or outside the extracted function.
The candidates to arguments of the function to be created are the variables defined
outside, however imported variables, whether from the language or from other libraries
does not have to be passed as arguments.
There are no information in the def-use-relations that indicates whether an variable
is imported or not.
We considered two possible solutions:
  -Def-use-relations + Text information
  -Def-use-relations + sExpressions

The first approach is simpler to implement and more direct than the second one.
However it is less tolerant to changes and to errors.
The second one combines the Arrow information with the syntax information to
check whether it is imported from the language or from other library.

We choose the second approach in order to provide the refactoring tool with a
better and lastly solution to compute correctly the arguments of the new function.

\subsubsection{Let to Defines}
%Refactoring Let to Defines Usefulness Vs implementation difficulty
%TODO implement

%let* vs let
There is a subtle difference between this two keywords that influences directly the simplicity of the solution.
the let defines variables independently, while let* can use the value of the variable defined before.
e.g.
There is a global variable a defined with value 10.
in the let we define variable a with 1 and variable b = a + 1
(let ([a 1]
[b (+ a 1)]))

\begin{lstlisting}[caption="Example"]
(define a 10)
(let ([a 1]
      [b (+ a 1)])
      ...
      )
\end{lstlisting}
This let, because it defines the variables independently the value of b is 11.

\begin{lstlisting}[caption="Example"]
(define a 10)
(let* ([a 1]
      [b (+ a 1)])
      ...
      )
\end{lstlisting}
However in the case of let* the value of b is 2.

let* simplifies the creation of defines and removes the necessity of using the
keyword local to ensure semantic preservation.

While the keyword local helps semantic preservation, that is not used very often
and can make confusion to the programmer.

Therefore only let* would be considered because it is a more directly
representation of a function.

%named let.
Named let is a let that has a name and can be called, like a function.
It is directly mapped as a function and therefore might be useful to transform to a function.
The same applies from a function to a named let.

However this has a problem, a let form can be used in expressions, but the define can not.
In the vast majority of cases this refactoring is correct, but when a let is used in an expression
it is not correct and it changes the meaning of the program, transforming a correct
program in a incorrect one.


\subsubsection{Define to Let}
Refactoring Define to Let Usefulness Vs Implementation difficulty
%TODO implement.

\subsubsection{Ambiguities}
There are some cases where two types of syntax refactoring apply.
Eg:
\begin{lstlisting}[caption="Example"]
(if ?x
    (begin ?y ...)
    #f)
\end{lstlisting}
The two different refactoring transformations are possible:
\begin{lstlisting}[caption="Example"]
(when ?x
      ?y ...)
\end{lstlisting}

\begin{lstlisting}[caption="Example"]
(and ?x (begin ?y ...))
\end{lstlisting}

The programmer could want in some situations choose one approach and in others
choose the other one. For example if a programmer is creating a predicate may
choose the and version, whereas if the programmer is using another control structure
may prefer the when version.

This example shows how hard it is to have an semi-automated refactoring tool
that gives suggestions.
It could displays both possibilities, but that will create an precedent meaning
that if a refactoring has several possibilities the tool has to display every one.
Or it could only display that there is a refactoring opportunity.
This requires further reflection to choose the best approach to the problem.


\subsubsection{Implemented Refactoring Operations:}

\section{Features}

\subsection{User FeedBack}
It is an important part of tool to give proper feedback to the user. It was studied
a way to inform users what were the conditions that did not let a refactoring operation
to occur. And which are the steps in order to do a certain refactoring
operation in the selected code instead of just disabling the refactoring operation
button. However after an analysis it was clear that kind of problems rarely occur
in Racket language and therefore not implemented. However if a language is statement
based instead of expression based the situation changes.

\subsection{Automated refactoring}
Automated refactoring, after finishing a project to make it more beautiful. (could be interesting)
This is already done, it calls every possible refactoring operation that the tool finds.
This is kinda dangerous to use, however this might be useful for the user to see all the results of the refactoring operations
and a good way to test if the refactoring operations do not change the meaning of the program.

\subsubsection{Automatic Suggesting refactoring opportunities.}
This feature is very useful in order to have a general idea what possible refactoring
operations can be done in a piece of software. It is also important for inexperienced
users because with this, they can have an idea what refactoring operations can be applied or not.
This features parses the code from the beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse. In other words it
uses brute force to check whether a expression can be refactored or not.

For now this is only applicable for syntax refactoring and not for extract-function.

In order to show the possible refactoring operations it highlights the source-code indicating
that there is a possible refactoring.

The Automatic suggesting can be easily extend to automatic refactoring. (and will be)

This features are a huge help to do the evaluation for two reasons.
First the automated refactoring displays all the possible refactoring found thus making it easier
to detect the refactoring operations in projects to evaluate the need to do the refactoring and to evaluate
if the refactoring tool (frameowork) is working correctly.
Second the automatic refactoring makes it easier to test if the refactoring operations are correct (**** for a limited test cases ****)
This is possible by running the test cases of the program before any refactoring.
Then using automatic refactoring in the program that applies all the refactoring that the tool finds.
And finally by running again the test cases of the program.
After testing it with several (or huge) programs if every test passes (or the exact same tests, because refactoring operations should not fix bugs)
we can consider that the refactoring operations are correct.


\subsubsection{Wide-Scope-Replacement:}
This is a huge improvement on the utility of the refactoring regarding the use
of the extract function refactoring operation. This searches for the code that is
duplicated of the extracted function and then it replaces for the call of the
extracted function.
This "refactoring-operation" is divided in two steps:
detecting duplicated code
Replacing the duplicated code

Replacing the duplicated code is the easy part, however the tool might has to compute
the arguments for the duplicated code itself. Doing that is not a trivial job and
that might be in the future work.

\subsubsection{Detecting duplicated code:}
This is the key for the correctness of this refactoring, even in the simplest way
that the code must be exactly equal, same names, same bindings, etc.
For example, if the duplicated code is in a let that changes some binding it must
be taken into consideration. Racket has already functions that compute if the bindings
are the same, however because the refactoring tool uses the program in the not expanded
form there is not enough information for those bindings to work.

[TODO Recently racket changed binding expansion and it brought interesting improvements
to racket and that might be useful for this, read paper before]

To solve this it is necessary to use the expanded form of the program in order
to compute the correct bindings. The naive solution is instead of using the
non expanded program to detect the duplicated code and then use this information
to do the replacing of the duplicated code. However when expanding the program
Racket adds necessary information to run the program itself that are not visible
for the user. while this does not change the detecting of the duplicated code,
because if the code is duplicated it will have the same extra information. It changes
the way the tool computes which code will be replaced.

In order to solve this problem in a simple way we can use the non expand program
to compute which code will be replaced. This runs after detecting the duplicated
code, so the bindings are corrected identified.

Detect possible refactoring operations (extract funcion):
This can be added to the automatic detection of possible refactoring operations
to be applied. notifying the users of a possible extract function operation.
This is a rather useful notification because for programs that are bigger than the
visible part of the screen. which might be difficulty for the user to remember
if a piece of code was duplicated or not.

However this detection is a quadratic algorithm (TODO check this) which might
have some performance problems for bigger programs.

\section{Analysis}
\subsection{HaRe}
\subsection{Scheme Griswold Implementation}
\subsection{Smalltalk Refactoring Browser}
\subsection{Javascript Framework}
\subsection{Bicycle Repair Man}
\subsection{Rope}
\subsection{pycharm}

\section{Plugin}
In order to improve the deployement and usage of the refactoring tool a plugin
for DrRacket was createad.
DrRacket has several advantages and the plugin support is another one, because
it allows a simple integration with DrRacket itsel a simple mananing interface.
Another advantage is the incorporation with git. A plugin can be a link for a git
repository and because of that it becomes simple to keep the refactoring tool up to date.

However, the main reason to create a plugin is to become independent from DrRacket
evolution. With a plugin that is possible and it is managable.

\section{Evaluation}
Case Study: (find a good ones) FP Project, Architecture Project.
Correctness:
\section{Future work}
Detect when a developer is refactoring in order to help the developer finish the
refactoring by doing it automatically.

Wide-scope-replacement smarter and better
