%\section{Racket Refactoring Tool}
%This section explains the decisions made in order to make this refactoring tool.

\section{Architecture}
%Refactoring Tool work flow: (add a brief explanation of what does )
The Refactoring tool uses mainly two sources of information, the def-use-relations and
the AST of the program.

The def-use-relations are visually represented in a form of Arrows in DrRacket,
that information is especially relevant for refactoring operations such as Extrac-Function,
Add-Prefix, Organize-Imports, etc.

The AST is represented by the s-expressions that compose the racket program. In
Racket everything is a syntax-expression and therefore accessing the list (tree)
of the syntax-expressions has all the information that a normal AST provides.


[INSERT IMAGE HERE]

%The AST is acquired after using the check-syntax button. It was intended to be
%acquired automatically, because DrRacket has an online check syntax, but it was
%not possible. After that it cleans the AST removing information that is not
%necessary, at least for now, for the refactoring operations. When the AST is cleaned it
%passes the exact part of the AST that was selected. And tries to match rules,
%using syntax-parse against that syntax.

\subsection{Def-Use-Relations}
DrRacket has def-use-relations in the system that are visually represented by
arrows. The information is computed in the online-comp.rkt that is where expands
and computes the information needed to know the def-use-relations and whether
the program is syntactically correct.
There is an online expansion monitor that calls the online-comp, the online-comp
then expands the program (to the expanded program) and does a trace to get the
information needed for the arrows (def-use-relations).
Afterwards it sends back that information to the caller of the online-comp to do
the replay of the trace did by the compile comp and to process the information
about the arrows.


\subsubsection{Def-Use-Relations utility}
Arrows can be used to check whether or not there is a duplicated name or to
compute the arguments of a function to be extracted.

\subsubsection{Arrow Evolution}
In previous versions of the online-comp information about the type of arrows
was available in the structure. However in the recent versions that type of
information was removed.
With the previous version of the online-comp the framework was computing the argument for the
newly extracted function using the type information: "one of 'lexical, 'top-level, 'import".
That change created a problem while trying to check whether an argument was imported
from the language or from another file/library that had at least two solutions:
  -Arrows + Text information
  -Arrows + sExpressions

The first approach is simpler and more direct than the second one. However it is
less tolerant to changes and to errors.
The second one combines the Arrow information with the syntax information to
check whether it is imported from the language or from other library.


\subsection{Syntax Expressions}
The Syntax expressions (s-exp) list are already being produced and used by the
Racket language and in DrRacket. They represent the program and are computed in
order to provide error information to the user.
DrRacket already provides functions in order to create s-exp lists and uses some of those
functions in the online check syntax and in the check syntax button callback.

[insert images here explaining that]


\subsubsection{Syntax Expression tree forms}
DrRacket provides functions to compute the s-exp list in two different formats.
One format is the expanded program, this format is used by the Check Syntax and
the online check syntax, and computes the program expanded.
The other format is the non-expanded program and computes the program unexpanded.

The expanded program has the macros expanded and the identifier information computed,
however it is harder to extract the relevant information when compared with the
non expanded program.
%Racket has two forms of syntax tree. An expanded form, with the macros expanded
%and a non expanded form that is after a read-syntax without the macros expanded.

For example, the following program is represented in the expanded program,
and in the non expanded program.
\begin{lstlisting}[caption="example"]
#lang racket
(if (= (+ 1 2) 1)
      #f
      #t)
\end{lstlisting}

\begin{lstlisting}[caption="Syntax from Example"]
#<syntax:3:0 (if (< 1 2) #t #f)>
\end{lstlisting}

\begin{lstlisting}[caption="Expanded Syntax from example"]
#<syntax:1:0 (module anonymous-module racket
  (#%module-begin (module configure-runtime
    (quote #%kernel)#%module-begin
      (#%require racket/runtime-config)
        (#%app configure (quote #f))))
          (#%app call-with-values (lambda ()
            (if (#%app < (quote 1) (quote 2))
              (quote #t) (quote #f))) print-values)))>
\end{lstlisting}

%Expanded Program Vs Not expanded Program
%Talk about difficulty, durability, Python (other languages)

%[Only in the expanded form] (and) is treated like an if which is bad and give problems
%The rest tends to work.
%testing:
%(if (= (+ 1 2) 1) \#f \#t) to (not (= (+ 1 2) 1))

The expanded program transforms the "and", "or", "when" and "unless" forms into
ifs and that makes refactoring operations harder to implement. Regarding that it
 also adds more information that the refactoring tool does not need, such as racket
 internal information, for the vast majority of the refactoring operations.
However, the expanded program has important information regarding the binding
information that is not available in the non-expanded form and is rather useful
to detect if two identifiers refer to the same binding.
In addition to that, the expanded program has a format that is likely to change
in the future because Racket is an evolving language and the expanded form is a
low level and internal form of representation of the program in Racket.
All those combined make it desirable to use the non expanded form for the refactoring
operations as much as possible and use the expanded form only for the necessary
step.


%Sub Cap Code with Macros The Problem [Stoped here 19/01/16]
However, if the program contains macros using the non expanded program may
result in semantic incorrect refactoring operations. This is not considered a
problem because this refactoring tool is aimed at unexperienced programmers (that
had one semester of programming classes) and those type of programmers do not use
macros. If we intended to create a tool for more experienced programmers the non
expanded program is insufficient and the expanded program must be used.


%Dependency of Racket evolution
Using the expanded program might simplify the refactoring for other languages,
for example it has a literal that says when the program returns in python, and
racket does not have it. In the expanded form there is syntax that explicitly says
where the program returns.

In the future it is possible to create a tool that uses both program expansions,
making it possible to have macros and the relation with other languages for the
more difficult problems and using the non expanded program for the simple cases.

Semantic problem (E.g. (and (< 1 (foo 2)) (< (foo 2) 3)) )
The refactoring operation that merges two ands into one, can change the semantic
form of the program. because if foo has collateral effects (changing the value of
a variable, printing some stuff, etc) it will only do that once, instead of twice.
changing the semantic of the program.

\subsection{Code-walker} % [TODO explain better]
It is used as a parser for the syntax tree.
the way that the code-walker guarantees that goes to every important part of the
tree is by having a "pointer" to the current selected syntax element, and have
a stack that contains the remaining code to analyze.
Each syntax element could be a syntax-pair, one syntax element or the empty list.
If it is a pair of syntax elements they are organized by (stx . pair)
In which the first element is a syntax element and the second one is a syntax pair.
A syntax pair is a pair containing a syntax object as it first element and
a syntax pair, a syntax element or an empty list as the second argument.
Because of this structure it is necessary to have a stack in order to search
the tree correctly and in the best way possible.
Because Most of the time we are searching for a specific syntax element (e.g function,
define, etc, because everything is a syntax element in Racket) and using this we
can skip uninteresting syntax in order to get to the syntax that we want to use.


%%%%%% Writing Part of the Refactoring/refactoring rule
\section{Syntax-Parse}
Syntax-Parse Utility
Racket gives a function that parses syntax. The Syntax-Parse provided by Racket
is rather useful. because besides having a wide range of auxiliary functions that
helps matching the syntax it also has backtracking. With Backtracking it is
possible to have several rules to be match in the same syntax parser which
helps to create more sophisticated rules.


\section{ Pretty Printing}

Pretty Printing (E.g. Cond lets etc)
The racket makes it easy to create syntax using the syntax-parse to transform the
AST into another AST. however the syntax elements (s-expressions) lose some information
about parenthesis. For example it is a convention that cond clauses should be
surrounded by [] parenthesis but the syntax element does not store that information
 among others. One possible solution to this problem is by using a pretty-printer.
 There are several pretty-printers developed for Racket and even the Racket language
 has one incorporated.
 The one already incorporated does not use the [ ] parenthesis, however racket
 supports both representations.

\subsection{Refactoring operations}

\subsubsection{Extract Functions}
Extract function is an important refactoring operation that every refactoring tool
should have. However is not that simple to implement and there are some things to
take into account.
In order to extract a function it is necessary to compute the arguments needed
to the correct use of the function. While naming the new function it is an interesting
feature to check if that name is duplicate.
Then computing the body and replacing it by the call should be straightforward.
Another problem is where should the function be extracted to. A function can not
be defined in an expression, (e.g inside a let) but it could be defined in the top-level
or in any other level that is accessible from the top level.

e.g: When extracting the \'(+ 1 2) to a function where should it be defined?
Top-level? level-0 level-1 or in the current level, level-2?
\begin{lstlisting}[caption="Example"]
;;top-level
(define (level-0)
  (define (level-1)
    (define (level-2)
      (+ 1 2))
    (level-2))
  (level-1))
\end{lstlisting}

The fact is that is extremely difficult to know the answer to this question, and
we think that the best solution to this question is to let the user decide where
he want the function defined.

Paste (etc)

\subsubsection{Let to Defines}
Refactoring Let to Defines Usefulness Vs implementation difficulty
let* vs let
There is a subtle difference between this two keywords that influences directly the simplicity of the solution.
the let defines variables independently, while let* can use the value of the variable defined before.
e.g.
There is a global variable a defined with value 10.
in the let we define variable a with 1 and variable b = a + 1
(let ([a 1]
[b (+ a 1)]))
This let, because it defines the variables independently the value of b is 11.
However if it was used let* the value of b would be 2.
let* simplifies the creation of defines and removes the necessity of using the keyword local to ensure semantic preservation.

While the keyword local helps semantic preservation, that is not used very often and can make confusion to the programmer.

Therefore only let* would be considered because it is a more directly representation of a function.

named let.
Named let is a let that has a name and can be called, like a function.
It is directly mapped as a function and therefore might be useful to transform to a function.
The same applies from a function to a named let.

However this has a problem. Let can be used in expressions, but the define can not.
In the vast majority of cases this refactoring is correct, but when a let is used in an expression
it is not correct and it changes the meaning of the program, transforming a correct
program in a incorrect one.
\subsubsection{Define to Let}
Refactoring Define to Let Usefulness Vs Implementation difficulty

\subsubsection{Ambiguities}
Refactoring (if ?x (begin ?y ...) \#f) could go either way:
(when ?x ?y ...)
or
(and ?x (begin ?y ...))

This example shows how hard it is to have an semi-automated refactoring tool
that gives suggestions. It could displays both possibilities, but that will
create an precedent meaning that if a refactoring has several possibilities the
tool has to display every one. Or it could only display that there is a
refactoring opportunity. This requires further reflection to choose the best
approach to the problem.
The programmer could want in some situations choose one approach and in others
choose the other one. For example if a programmer is creating a predicate may
choose the and version, whereas if the programmer is using another control structure
may prefer the when version.

\subsubsection{Implemented Refactoring Operations:}

\section{Features}

\subsection{User FeedBack}
It is an important part of tool to give proper feedback to the user. It was studied
a way to inform users what were the conditions that did not let a refactoring operation
to occur. And which are the steps in order to do a certain refactoring
operation in the selected code instead of just disabling the refactoring operation
button. However after an analysis it was clear that kind of problems rarely occur
in Racket language and therefore not implemented. However if a language is statement
based instead of expression based the situation changes.

\subsection{Automated refactoring}
Automated refactoring, after finishing a project to make it more beautiful. (could be interesting)
This is already done, it calls every possible refactoring operation that the tool finds.
This is kinda dangerous to use, however this might be useful for the user to see all the results of the refactoring operations
and a good way to test if the refactoring operations do not change the meaning of the program.

\subsubsection{Automatic Suggesting refactoring opportunities.} %[Done]
This feature is very useful in order to have a general idea what possible refactoring
operations can be done in a piece of software. It is also important for inexperienced
users because with this, they can have an idea what refactoring operations can be applied or not.
This features parses the code from the beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse. In other words it
uses brute force to check whether a expression can be refactored or not.

For now this is only applicable for syntax refactoring and not for extract-function.

In order to show the possible refactoring operations it highlights the source-code indicating
that there is a possible refactoring.

The Automatic suggesting can be easily extend to automatic refactoring. (and will be)

This features are a huge help to do the evaluation for two reasons.
First the automated refactoring displays all the possible refactoring found thus making it easier
to detect the refactoring operations in projects to evaluate the need to do the refactoring and to evaluate
if the refactoring tool (frameowork) is working correctly.
Second the automatic refactoring makes it easier to test if the refactoring operations are correct (**** for a limited test cases ****)
This is possible by running the test cases of the program before any refactoring.
Then using automatic refactoring in the program that applies all the refactoring that the tool finds.
And finally by running again the test cases of the program.
After testing it with several (or huge) programs if every test passes (or the exact same tests, because refactoring operations should not fix bugs)
we can consider that the refactoring operations are correct.


\subsubsection{Wide-Scope-Replacement:}
This is a huge improvement on the utility of the refactoring regarding the use
of the extract function refactoring operation. This searches for the code that is
duplicated of the extracted function and then it replaces for the call of the
extracted function.
This "refactoring-operation" is divided in two steps:
detecting duplicated code
Replacing the duplicated code

Replacing the duplicated code is the easy part, however the tool might has to compute
the arguments for the duplicated code itself. Doing that is not a trivial job and
that might be in the future work.

\subsubsection{Detecting duplicated code:}
This is the key for the correctness of this refactoring, even in the simplest way
that the code must be exactly equal, same names, same bindings, etc.
For example, if the duplicated code is in a let that changes some binding it must
be taken into consideration. Racket has already functions that compute if the bindings
are the same, however because the refactoring tool uses the program in the not expanded
form there is not enough information for those bindings to work.

[TODO Recently racket changed binding expansion and it brought interesting improvements
to racket and that might be useful for this, read paper before]

To solve this it is necessary to use the expanded form of the program in order
to compute the correct bindings. The naive solution is instead of using the
non expanded program to detect the duplicated code and then use this information
to do the replacing of the duplicated code. However when expanding the program
Racket adds necessary information to run the program itself that are not visible
for the user. while this does not change the detecting of the duplicated code,
because if the code is duplicated it will have the same extra information. It changes
the way the tool computes which code will be replaced.

In order to solve this problem in a simple way we can use the non expand program
to compute which code will be replaced. This runs after detecting the duplicated
code, so the bindings are corrected identified.

Detect possible refactoring operations (extract funcion):
This can be added to the automatic detection of possible refactoring operations
to be applied. notifying the users of a possible extract function operation.
This is a rather useful notification because for programs that are bigger than the
visible part of the screen. which might be difficulty for the user to remember
if a piece of code was duplicated or not.

However this detection is a quadratic algorithm (TODO check this) which might
have some performance problems for bigger programs.

\section{Analysis}
\subsection{HaRe}
\subsection{Scheme Griswold Implementation}
\subsection{Smalltalk Refactoring Browser}
\subsection{Javascript Framework}
\subsection{Bicycle Repair Man}
\subsection{Rope}
\subsection{pycharm}

\section{Plugin}
In order to improve the deployement and usage of the refactoring tool a plugin
for DrRacket was createad.
DrRacket has several advantages and the plugin support is another one, because
it allows a simple integration with DrRacket itsel a simple mananing interface.
Another advantage is the incorporation with git. A plugin can be a link for a git
repository and because of that it becomes simple to keep the refactoring tool up to date.

However, the main reason to create a plugin is to become independent from DrRacket
evolution. With a plugin that is possible and it is managable.

\section{Evaluation}
Case Study: (find a good ones) FP Project, Architecture Project.
Correctness:
\section{Future work}
Detect when a developer is refactoring in order to help the developer finish the
refactoring by doing it automatically.

Wide-scope-replacement smarter and better
