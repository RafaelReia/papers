\section{Related Work}
\label{sec:Related-Work}
Several refactoring tools were analyzed to guide our development.
Our focus was on dynamic languages which are used in introductory courses or that have similarities
with the Racket Language.

\subsection{Scheme}
A refactoring tool \cite{griswold1991program} for scheme, implemented in Lisp that
uses two forms of information, AST (Abstract Syntax Tree) and PDG (Program Dependence Graph).

The AST represents the abstract syntactic structure of the program.
While the PDG explicitly represents the key relationship of dependence between
operations in the program. %control flow!
The graph vertices's represent program operations and the edges represent the flow of
data and control between operations.
However, the PDG only has dependency information of the program and relying only
in this information to represent the program could create problems.
For example, if two semantically unrelated statements they could be placed arbitrarily with
respect to each other.
Using the AST as the main representation of the program ensures that statements
are not arbitrarily reordered.
While the PDG is only used as a notation to prove that transformations preserve
the meaning and as a quick way to retrieve needed dependence information.
Contours are used with the PDG providing scope information, which is non existent in the PDG,
to help reason about transformations in the PDG.
%Rewrite, talk about the scopes
With these structures it is possible to have a single formalism to reason effectively
about flow dependencies and scope structure.
\subsection{Haskell}
HaRe \cite{thompson2005refactoring} is a refactoring tool for Haskell that
integrates with Emacs and Vim.
%(abstract syntax tree)
The HaRe system uses an AST of the program to be
refactored in order to reason about the transformations to do.
The system has also a token stream in order to preserve the comments and the
program layout by keeping information about the source code location and the comments of all tokens.
It retrieves scope information from the AST, that allows to have refactoring operations that
require binding information of variables. %so a def-use-relation?
The system also allows the users to design their own refactoring operations
using the HaRe API.
\subsection{Python}

\subsubsection{Rope}
Rope\cite[p.~109]{govindaraj2015test} is a Python refactoring tool written in Python, which works like a Python library.
In order to make it easier to create refactoring operations, Rope assumes that a
Python program only has assignments and functions calls. %(can this be a bad thing?)
Thus, by limiting the complexity of the language it reduces the complexity of the
refactoring tool.

Rope uses a Static Object Analysis, which analyses the modules or scope to get
information about functions.
Rope only analyses the scopes when they change and it only analyses the modules
when asked by the user, because this approach is time consuming.

Rope also uses a Dynamic Object Analysis that requires running
the program in order to work.
The Dynamic Object Analysis gathers type information and parameters passed to and returned from
functions in order to get all the information needed.
It stores the information collected by the analysis in a database.
If Rope needs the information and there is nothing on the database the Static
object inference starts trying to infer the object information.
This approach makes the program run much slower, thus it is only active when
the user decides. %TODO improve "user decides"
Rope uses an AST in order to store the syntax information about the programs.

\subsubsection{Bicycle Repair Man}
Bicycle Repair Man\footnote{https://pypi.python.org/pypi/bicyclerepair/0.7.1} is a refactoring tool for Python written in Python.
 This refactoring tool can be added to IDEs and editors, such as Emacs, Vi, Eclipse,
  and Sublime Text.
It attempts to create the refactoring browser functionality for
 Python and has the following refactoring operations:
 extract method, extract variable, inline variable, move to module, and rename.

The tool has an AST to represent the program and a database that has information
about several program entities and dependency information.

\subsubsection{Pycharm Edu}
Pycharm Educational Edition,\footnote{https://www.jetbrains.com/pycharm-edu/}
 or Pycharm Edu, is a IDE for Python created by JetBrains,
the creator of IntelliJ.
The IDE was specially designed for the educational purpose, for programmers
with little or no previous coding experience.
Pycharm Edu is a simpler version of Pycharm community which is the free
python IDE created by JetBrains.
Therefore it is very similar to their normal IDEs and it has interesting features
such as code completion, version control tools integration.
However, it has a simpler interface when compared with
Pycharm Community and other IDEs such as Eclipse or Visual Studio. %good for beginners, explain

It has integrated a python tutorial and the big advantage is the possibility of
the teachers creating tasks/tutorials for the students.
However, the refactoring tool did not received the same care as the IDE itself.
The refactoring operations are exactly the as the Pycharm community IDE which were made
for more advanced users.
Therefore it does not provide specific refactoring operations to beginners.
The embedded refactoring tool uses the AST and def-use-relations in the refactoring
operations.

\subsection{Javascript}
There are few refactoring tools for JavaScript but there is a framework
\cite{feldthaus2011tool} for refactoring JavaScript programs. %FIXME I do not like it
In order to guarantee the correctness of the refactoring operation, the framework
uses preconditions, expressed as query analyses provided by pointer analysis. %TODO explain better!
Queries to the pointer analysis produces over-approximations of sets in a safe way to
have correct refactoring operations.
For example, while doing a rename operation, it over-approximates the set of expressions
that must be modified when a property is renamed in a safe manner.
%FIXME explained enough?
e.g: A set {\tt L} of object labels over-approximates a set {\tt O} of runtime objects if every
object {\tt o $\in$ O} is represented by some {\tt l $\in$ L}.

To prove the concept, three refactoring operations were implemented, namely rename,
encapsulate property, and extract module.
By using over-approximations it is possible to be sure when a refactoring
operation is valid.
However, this approach has the disadvantage of not applying every possible refactoring operation,
because the refactoring operations for which the framework cannot guarantee behavior
preservation are prevented.
The wrongly prevented operations accounts for 6.2\% of all rejections.
