\section{Features}

\subsection{User FeedBack}
It is important to give proper feedback to the user while the user is preforming
the refactoring operations.
It was studied the best form to inform users what were the conditions that did not allow %FIXME did/do?
a refactoring operation.
And also, how to inform which are the steps in order to allow that refactoring operation to occur,
instead of just disabling the refactoring button.
However after an analysis it was clear that these situations rarely occur
in Racket language and therefore it was not implemented.
However if a language is statement based instead of expression based the situation changes
and the importance of the User Feedback increases. %becomes critical?

\subsection{Refactoring Preview}
An important goal of this refactoring tool is to let beginner users to know what
refactoring operations exist, what they do, and how to use them.
Previewing the outcome of a refactoring operation is an efficient form to
help the users understand the result of a refactoring before even applying the refactoring. %FIXME or understand what a refactoring operation is/do
Previewing works by applying the refactoring operation in a copy version of the AST
and displaying those changes to the user.
%insert image?

\subsection{Wide-Scope Replacement} %is this a feature or a refactoring?
The Wide-Scope replacement brings the possibility to replace all the duplicated
code with a function call. This is usually performed after an extract function refactoring.
The Wide-Scope Replacement brings an huge improvement on the utility of the refactoring regarding the use
of the extract function refactoring operation.

It searches for the code that is duplicated of the extracted function and then it replaces for the call of the
extracted function.
The Wide-Scope replacement refactoring operation is divided in two steps: %FIXME Improve
detect duplicated code
Replace the duplicated code

Replacing the duplicated code is the easy part, however the tool might has to compute %have?
the arguments for the duplicated code itself. The argument computation occurs when
the code is the same, but it has different variable names. This is not yet in this
version of the refactoring tool. %TODO rewrite, it is buggy

\subsubsection{Detecting duplicated code}
Correctly detect code duplication is a key part for the correctness of this refactoring.
Even the simplest form of duplicated code detection, when it only detects code duplication
when the code is exactly equal, may have some problems regarding the bindings.
For example, if the duplicated code is inside a let that changes some binding that must
be taken into consideration.
Racket already provides functions that compute if the bindings are the same.
However that does not work if we consider the program in the not expanded
form because there is not enough information for those bindings to work. %FIXME improve :(

%[TODO Recently racket changed binding expansion and it brought interesting improvements to racket and that might be useful for this, read paper before]

Therefore, in order to compute the correct bindings, it is necessary to use the expanded form
of the program.

The naive solution is to use the expanded program to detect the duplicated
 code and then use this information to do the replacing of the duplicated code.
However when expanding the program Racket adds necessary internal information to
run the program itself that are not visible for the user.
While this does not change the detecting of the duplicated code, this adds unnecessary information
that would have to be removed. %FIXME
In order to solve this problem in a simple way we can use the expanded code to detect
the correctly duplicated code and use the non expand program
to compute which code will be replaced.

However this detection is a quadratic algorithm (TODO check this) which might
have some performance problems for bigger programs. %TODO TODO TODO

Detecting duplicated code can be added to the automatic detection of possible refactoring operations to be applied. %FIXME is this already done?
Notifying the users of a possible extract function operation if there is duplicated code.
This is a rather useful notification because for programs that are bigger than the
visible part of the screen.
Which might be difficulty for the user to remember if a piece of code was duplicated or not.


%This runs after detecting the duplicated code, so the bindings are corrected identified.

\subsubsection{Automatic Suggesting}
Automatic Suggesting refactoring opportunities like the name suggests it suggests
possible refactoring operations to the users.
This feature is rather useful in order to have a general idea what possible refactoring
operations can be done in a piece of software. %FIXME code?
It is also important for inexperienced users because with this feature,
they can have an idea what refactoring operations can be applied or not.


In order to detect possible refactoring operations it parses the code from the
beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse.
In other words it uses brute force to check whether a expression can be applied
a refactoring operation or not.
Automatic Suggesting is mainly applied to syntax refactoring operations, however
it could be applied to the Extract-Function refactoring operation using the
simple detection of duplicated code to inform the user that might be useful
to extract a function instead of having duplicated code. %FIXME too big!

To properly display this information it highlights the source-code indicating
that there is a possible refactoring.
This feature could be improved by having a set of colors for the different types
of refactoring operations. And the color intensity could be proportional to the level
of suggestion. (e.g the recommended level to use extract function refactoring
increases with the number of duplicated code found) %maybe produce an example?


\subsection{Automated refactoring}
Automatic refactoring is an option that the user decides to let the refactoring
tool do every refactoring operation that it founds. It is a feature that usually used
after the automatic suggesting and when the user wants that every refactoring operation
found to be applied.
%FIXME THIS IS SUPER DANGEROUS!
%The Automatic suggesting can be easily extend to automatic refactoring.
%Automated refactoring, after finishing a project to make it more beautiful. (could be interesting)
%This is already done, it calls every possible refactoring operation that the tool finds.
%This is kinda dangerous to use, however this might be useful for the user to see all the results of the refactoring operations
%and a good way to test if the refactoring operations do not change the meaning of the program.


\section{Analysis}
%It was made an analysis to compare the refactoring tool with the others
%TODO table information is available in GIT repository
%TODO what my tool is different, what it is equal
\begin{table}[]
\centering
\caption{Data Structures}
\label{my-label}
\begin{tabular}{c|c|c|c|c}
Name     & AST & PDG & Database & Others \\ \hline
Griswold & X   & X   &          &        \\ \hline
HaRe     & X   &     &          &        \\ \hline
Rope     & X   &     & X        &        \\ \hline
Bicycle  & X   &     & X        &
\end{tabular}
\end{table}
%TODO Add JAVASCRIPT, Pycharm?
%more refactoring tools?
%Javascript Framework
%pycharm

This table summarizes the data structures of the refactoring tools deeply analyzed.
It is clear that the AST of a program is an essential part of the refactoring
tool information with every Refactoring tool having an AST to represent the program.
Regarding the PDG and Database it has mainly information about the def-use-relation
of the program. The PDG has also control flow information among others.

HaRe only uses the AST as a source of information of the program. Thus, by not having
the def-use-relation or a PDG it has less information to perform the refactoring operations.
However because HaRe is for the Haskell program language that is purely-functional
programming language that extra information is not necessary to perform a good set of
refactoring operations correctly.



Our developed tool uses the same types of information, namely the AST and the def-use-relations.
Some tools like the one build by Griswold has more information available when compared
to the one developed by us.
However we find out that for expression based languages such as racket and focused
in the functional part it is sufficient an AST and def-use-relations.%FIXME!!!

The main difference is in the objectives of each refactoring tool.
Some like the refactoring tool build by Griswold focus on the correctness of the refactoring
operations.
Others, in the operations available but more focused on professional users.
However, the goal of this refactoring tool is to provide refactoring operations
designed for beginners. %FIXME
Therefore we are not interested in having refactoring operations formerly proven %FIXME REWRITE
correct or advanced and complex refactoring operations. %FIXME where is the comma??
We intend to have simple, useful, and correct for the usual use cases a beginner would use.
With this we set our refactoring operations scope to exclude macros usage, classes
and other complex structures.


%TODO add I already used the refactoring tool to do a refactoring operation in
%the source code of the refactoring tool. However this is only applicable in the parts that are supported by this refactoring tool.
