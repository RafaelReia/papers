\section{Features}
This section describes some of the features created to improve the usability by providing
sufficient feedback to the user, and way to inform the user of the presence
of the typical mistakes made by beginners.
\subsection{User FeedBack}
It is important to give proper feedback to the user while the user is attempting or
preforming a refactoring operation.
Previewing the outcome of a refactoring operation is an efficient form to
help the users understand the result of a refactoring before even applying the refactoring. %FIXME or understand what a refactoring operation is/do
It works by applying the refactoring operation in a copy version of the AST
and displaying those changes to the user.
%It was also studied the possibility of giving feedback to the user instead of
%just disabling the refactoring operation button when the tool could not perform the refactoring operation.
%The tool should provide information about the steps needed in order to be possible to apply
% that refactoring operation.
%However, after an analysis it was clear that these situations rarely occur
%in Racket language and therefore it was not implemented.

\subsection{Automatic Suggestions}
Beginner programmers usually do not know which refactoring operations exist or
which can be applied.
By having a automatic suggestion of the possible refactoring operations available
 the beginner programmer can have an idea what refactoring operations can be
 applied or not.

In order to detect possible refactoring operations it parses the code from the
beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse.
In other words it uses brute force to check whether a expression can be applied
a refactoring operation or not.

To properly display this information it highlights the source-code indicating
that there is a possible refactoring.
This feature could be improved by having a set of colors for the different types
of refactoring operations.
Moreover, the color intensity could be proportional to the level
of suggestion. e.g the recommended level to use extract function refactoring
increases with the number of duplicated code found.


\section{Analysis}
\begin{table}[]
\centering
\caption{Data Structures}
\label{tab:my-table}
\begin{tabular}{c|c|c|c|c}
Name       & AST & PDG & Database & Others \\ \hline
Griswold   & X   & X   &          &        \\ \hline
Rope       & X   &     & X        &        \\ \hline
Bicycle    & X   &     & X        &        \\ \hline
Pycharm Edu & X   &     & X        &        \\ \hline
Javascript &     &     &          & X
\end{tabular}
\end{table}

The Table~\ref{tab:my-table} summarizes the data structures of the analyzed refactoring tools.
It is clear that the AST of a program is an essential part of the refactoring
tool information with every refactoring tool having an AST to represent the program.
Regarding the PDG and Database it contains mainly information about the def-use-relation
of the program. The PDG has also control flow information of the program.
Our implementation uses the same data structures, the AST and
the def-use-relations.

%HaRe only uses the AST as a source of information of the program. Thus, by not having
%the def-use-relation or a PDG it has less information to perform the refactoring operations.
%However, because HaRe is for the Haskell program language that is purely-functional
%programming language that extra information is not necessary to perform a good set of
%refactoring operations correctly.


Some tools like the one build by Griswold focus on the correctness of the refactoring
operations and therefore need more information about the program, such as the information
provided by the PDG.
Others, focus in offering refactoring operations for professional or advanced users.
However, the goal of our refactoring tool is to provide refactoring operations
designed for beginners.
Therefore we are not interested in refactoring operations formerly proven
correct or provide refactoring operations only used in advanced and complex use cases.

We intend to have simple, useful, and correct refactoring operations to correct the typical mistakes made by beginners.
With this we exclude from the refactoring tool scope  macros usage, classes, and other complex structures
not often used by beginners.

%Added in evaluation: I already used the refactoring tool to do a refactoring operation in
%the source code of the refactoring tool. However this is only applicable in the parts that are supported by this refactoring tool.
