\section{Features}

\subsection{User FeedBack}
It is important to give proper feedback to the user while the user is preforming
the refactoring operations.
It was studied the best form to inform users what were the conditions that did not allow %FIXME did/do?
a refactoring operation.
And also, how to inform which are the steps in order to allow that refactoring operation to occur,
instead of just disabling the refactoring button.
However after an analysis it was clear that these situations rarely occur
in Racket language and therefore it was not implemented.
However if a language is statement based instead of expression based the situation changes
and the importance of the User Feedback increases. %becomes critical?

\subsection{Refactoring Preview}
An important goal of this refactoring tool is to let beginner users to know what
refactoring operations exist, what they do, and how to use them.
Previewing the outcome of a refactoring operation is an efficient form to
help the users understand the result of a refactoring before even applying the refactoring. %FIXME or understand what a refactoring operation is/do
Previewing works by applying the refactoring operation in a copy version of the AST
and displaying those changes to the user.
%insert image?

\subsection{Wide-Scope Replacement} %is this a feature or a refactoring?
The Wide-Scope replacement brings the possibility to replace all the duplicated
code with a function call. This is usually performed after an extract function refactoring.
The Wide-Scope Replacement brings an huge improvement on the utility of the refactoring regarding the use
of the extract function refactoring operation.

It searches for the code that is duplicated of the extracted function and then it replaces for the call of the
extracted function.
The Wide-Scope replacement refactoring operation is divided in two steps: %FIXME Improve
detect duplicated code
Replace the duplicated code

Replacing the duplicated code is the easy part, however the tool might has to compute %have?
the arguments for the duplicated code itself. The argument computation occurs when
the code is the same, but it has different variable names. This is not yet in this
version of the refactoring tool. %TODO rewrite, it is buggy

\subsubsection{Detecting duplicated code}
Correctly detect code duplication is a key part for the correctness of this refactoring.
Even the simplest form of duplicated code detection, when it only detects code duplication
when the code is exactly equal, may have some problems regarding the bindings.
For example, if the duplicated code is inside a let that changes some binding that must
be taken into consideration.
Racket already provides functions that compute if the bindings are the same.
However that does not work if we consider the program in the not expanded
form because there is not enough information for those bindings to work. %FIXME improve :(

%[TODO Recently racket changed binding expansion and it brought interesting improvements to racket and that might be useful for this, read paper before]

Therefore, in order to compute the correct bindings, it is necessary to use the expanded form
of the program.

The naive solution is to use the expanded program to detect the duplicated
 code and then use this information to do the replacing of the duplicated code.
However when expanding the program Racket adds necessary internal information to
run the program itself that are not visible for the user.
While this does not change the detecting of the duplicated code, this adds unnecessary information
that would have to be removed. %FIXME
In order to solve this problem in a simple way we can use the expanded code to detect
the correctly duplicated code and use the non expand program
to compute which code will be replaced.

However this detection is a quadratic algorithm (TODO check this) which might
have some performance problems for bigger programs. %TODO TODO TODO

Detecting duplicated code can be added to the automatic detection of possible refactoring operations to be applied. %FIXME is this already done?
Notifying the users of a possible extract function operation if there is duplicated code.
This is a rather useful notification because for programs that are bigger than the
visible part of the screen.
Which might be difficulty for the user to remember if a piece of code was duplicated or not.


%This runs after detecting the duplicated code, so the bindings are corrected identified.

\subsubsection{Automatic Suggesting}
Automatic Suggesting refactoring opportunities like the name suggests it suggests
possible refactoring operations to the users.
This feature is rather useful in order to have a general idea what possible refactoring
operations can be done in a piece of software. %FIXME code?
It is also important for inexperienced users because with this feature,
they can have an idea what refactoring operations can be applied or not.


In order to detect possible refactoring operations it parses the code from the
beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse.
In other words it uses brute force to check whether a expression can be applied
a refactoring operation or not.
Automatic Suggesting is mainly applied to syntax refactoring operations, however
it could be applied to the Extract-Function refactoring operation using the
simple detection of duplicated code to inform the user that might be useful
to extract a function instead of having duplicated code. %FIXME too big!

To properly display this information it highlights the source-code indicating
that there is a possible refactoring.
This feature could be improved by having a set of colors for the different types
of refactoring operations. And the color intensity could be proportional to the level
of suggestion. (e.g the recommended level to use extract function refactoring
increases with the number of duplicated code found) %maybe produce an example?


\subsection{Automated refactoring}
Automatic refactoring is an option that the user decides to let the refactoring
tool do every refactoring operation that it founds. It is a feature that usually used
after the automatic suggesting and when the user wants that every refactoring operation
found to be applied.
%FIXME THIS IS SUPER DANGEROUS!
%The Automatic suggesting can be easily extend to automatic refactoring.
%Automated refactoring, after finishing a project to make it more beautiful. (could be interesting)
%This is already done, it calls every possible refactoring operation that the tool finds.
%This is kinda dangerous to use, however this might be useful for the user to see all the results of the refactoring operations
%and a good way to test if the refactoring operations do not change the meaning of the program.


\section{Tool Maintenance}
%Developer Point of view
%%%% Nor for the paper tough %%%%
%%automatic might help save work when the user nows what exactly the tool will do.

%This feature combined with the automatic suggesting is a huge help to do the
%evaluation of this refactoring tool and to use in battery tests.
A refactoring tool is a quite complex piece of software and therefore it needs maintenance.
Automatic testing is used in general by developers to ensure that the software
is doing OK for those test cases and to be run after changing some part of the code.
By having a way to automatically perform all the refactoring operations found,
the developer of a refactoring tool can test if the changes made did not introduce
bugs in other refactoring operations of the refactoring tool. %TODO continue
First the automated refactoring displays all the possible refactoring found thus making it easier
to detect the refactoring operations in projects.
It makes it easier to evaluate the need to do the refactoring and to evaluate
if the refactoring tool (frameowork) is working correctly.
Second the automatic refactoring makes it easier to test if the refactoring operations are correct (**** for a limited test cases ****)
This is possible by running the test cases of the program before any refactoring.
Then using automatic refactoring in the program that applies all the refactoring that the tool finds.
And finally by running again the test cases of the program.
After testing it with several (or huge) programs if every test passes (or the exact same tests, because refactoring operations should not fix bugs)
we can consider that the refactoring operations are correct.


\section{Analysis}
%It was made an analysis to compare the refactoring tool with the others
\begin{table}[]
\centering
\caption{Data Structures}
\label{my-label}
\begin{tabular}{c|c|c|c|c}
Name     & AST & PDG & Database & Others \\ \hline
Griswold & X   & X   &          &        \\ \hline
HaRe     & X   &     &          &        \\ \hline
Rope     & X   &     & X        &        \\ \hline
Bicycle  & X   &     & X        &
\end{tabular}
\end{table}
%TODO Add Smalltalk?
%more refactoring tools?
This table summarizes the data structures of the refactoring tools deeply analyzed.
It is clear that the AST of a program is an essential part of the refactoring
tool information with every Refactoring tool having an AST to represent the program.
Regarding the PDG and Database it has mainly information about the def-use-relation
of the program. The PDG has also control flow information among others.

HaRe only uses the AST as a source of information of the program. Thus, by not having
the def-use-relation or a PDG it has less information to perform the refactoring operations.
However because HaRe is for the Haskell program language that is purely-functional
programming language that extra information is not necessary to perform a good set of
refactoring operations correctly.

Our developed tool uses the same kind of information, namely the AST and the def-use-relations.
Some tools like the one build by Griswold has more information available when compared
to the one developed by us. However we find out that for expression based languages
such as racket and focused in the functional part it is sufficient an AST and
def-use-relations.



%HaRe Scheme Griswold Implementation
%Smalltalk Refactoring Browser
%Javascript Framework
%Bicycle Repair Man
%Rope
%pycharm

%TODO add in what my tool is different from the others? in what it is equal?
%TODO add I already used the refactoring tool to do a refactoring operation in
%the source code of the refactoring tool. However this is only applyable in the parts that are supported by this refactoring tool.
