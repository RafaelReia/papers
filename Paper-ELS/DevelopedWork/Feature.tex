\section{Features}
This section describes some of the features that improve the utility of this
refactoring tool to beginner users. %TODO shall I name them?
\subsection{User FeedBack}
It is important to give proper feedback to the user while the user is atempting or
 preforming refactoring operations.
Instead of just disabling the refactoring operation button the tool should
 provide information about the steps needed in order to be possible to apply
 that refactoring operation.
However, after an analysis it was clear that these situations rarely occur
in Racket language and therefore it was not implemented.
However if a language is statement based instead of expression based the situation changes
and the importance of the User Feedback increases. %becomes critical?

%\subsection{Refactoring Preview}
Previewing the outcome of a refactoring operation is an efficient form to
help the users understand the result of a refactoring before even applying the refactoring. %FIXME or understand what a refactoring operation is/do
Previewing works by applying the refactoring operation in a copy version of the AST
and displaying those changes to the user.

%An important goal of this refactoring tool is to let beginner users to know what
%refactoring operations exist, what they do, and how to use them.
%insert image?

\subsection{Automatic Suggestions}
Beginner programmers usually do not know which refactoring operations exist or
which can be applied.
By having a automatic suggestion of the possible refactoring operations available
 the beginner programmer can have an idea what refactoring operations can be
 applied or not.

In order to detect possible refactoring operations it parses the code from the
beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse.
In other words it uses brute force to check whether a expression can be applied
a refactoring operation or not.
%Automatic Suggesting is mainly applied to syntax refactoring operations, however
%it could be applied to the Extract-Function refactoring operation using the
%simple detection of duplicated code to inform the user that might be useful
%to extract a function instead of having duplicated code. %FIXME too big!

To properly display this information it highlights the source-code indicating
that there is a possible refactoring.
This feature could be improved by having a set of colors for the different types
of refactoring operations. And the color intensity could be proportional to the level
of suggestion. (e.g the recommended level to use extract function refactoring
increases with the number of duplicated code found) %maybe produce an example?


\section{Analysis}
%It was made an analysis to compare the refactoring tool with the others
%TODO table information is available in GIT repository
%TODO what my tool is different, what it is equal
\begin{table}[]
\centering
\caption{Data Structures}
\label{my-label}
\begin{tabular}{c|c|c|c|c}
Name       & AST & PDG & Database & Others \\ \hline
Griswold   & X   & X   &          &        \\ \hline
HaRe       & X   &     &          &        \\ \hline
Rope       & X   &     & X        &        \\ \hline
Bicycle    & X   &     & X        &        \\ \hline
Pycharm    & X   &     & X        &        \\ \hline
Javascript &     &     &          & X
\end{tabular}
\end{table}
%TODO Add JAVASCRIPT, Pycharm?
%more refactoring tools?
%Javascript Framework
%pycharm

The table summarizes the data structures of the refactoring tools deeply analyzed.
It is clear that the AST of a program is an essential part of the refactoring
tool information with every Refactoring tool having an AST to represent the program.
Regarding the PDG and Database it has mainly information about the def-use-relation
of the program. The PDG has also control flow information among others.

HaRe only uses the AST as a source of information of the program. Thus, by not having
the def-use-relation or a PDG it has less information to perform the refactoring operations.
However because HaRe is for the Haskell program language that is purely-functional
programming language that extra information is not necessary to perform a good set of
refactoring operations correctly.



%Our developed tool uses the same types of information, namely the AST and the def-use-relations.
%Some tools like the one build by Griswold has more information available when compared
%to the one developed by us.
%However we find out that for expression based languages such as racket and focused
%in the functional part it is sufficient an AST and def-use-relations.%FIXME!!!

Our implementation uses the same data structures, the AST and
def-use-relations. The def-use-relation is often represented as a database,
some refactoring tools annotate that information in the AST, %haskell v2
some tools extract the information from the AST itself when it is possible and
it is possible to extract that information from the PDG.
Some tools have more information about the program, either because they need that
information to perform the refactoring operation or because they need to prove that
the refactoring is correct.  %case of pycharm/python && Griswold

%Undoubtedly the main difference is in the objectives of each refactoring tool.
Some tools like the one build by Griswold focus on the correctness of the refactoring
operations.
Others, focus in offering refactoring operations for professional or advanced users.
However, the goal of our refactoring tool is to provide refactoring operations
designed for beginners. %FIXME suited aimed targeted
Therefore we are not interested in refactoring operations formerly proven %FIXME REWRITE
correct or provide refactoring operations only used in advanced and complex use cases. %FIXME where is the comma??
We intend to have simple, useful, and correct refactoring operations for the usual use cases a beginner would use.
With this set of scope we exclude macros usage, classes and other complex structures %TODO check this!
not used by beginners.


%TODO add I already used the refactoring tool to do a refactoring operation in
%the source code of the refactoring tool. However this is only applicable in the parts that are supported by this refactoring tool.
