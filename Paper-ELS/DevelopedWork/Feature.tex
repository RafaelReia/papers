\section{Features}
This section describes some of the features that improve the utility of this
refactoring tool to beginner programmers. %TODO shall I name them?
\subsection{User FeedBack}
It is important to give proper feedback to the user while the user is attempting or
preforming refactoring operations.
Previewing the outcome of a refactoring operation is an efficient form to
help the users understand the result of a refactoring before even applying the refactoring. %FIXME or understand what a refactoring operation is/do
It works by applying the refactoring operation in a copy version of the AST
and displaying those changes to the user.
It was also studied the possibility of giving feedback to the user instead of
just disabling the refactoring operation button when the tool could not perform the refactoring operation.
The tool should provide information about the steps needed in order to be possible to apply
 that refactoring operation.
However, after an analysis it was clear that these situations rarely occur
in Racket language and therefore it was not implemented.


\subsection{Automatic Suggestions}
Beginner programmers usually do not know which refactoring operations exist or
which can be applied.
By having a automatic suggestion of the possible refactoring operations available
 the beginner programmer can have an idea what refactoring operations can be
 applied or not.

In order to detect possible refactoring operations it parses the code from the
beginning to the end and tries to check if a refactoring is applicable.
To do that it tries to match every syntax expression using syntax parse.
In other words it uses brute force to check whether a expression can be applied
a refactoring operation or not.

To properly display this information it highlights the source-code indicating
that there is a possible refactoring.
This feature could be improved by having a set of colors for the different types
of refactoring operations.
Moreover, the color intensity could be proportional to the level
of suggestion. (e.g the recommended level to use extract function refactoring
increases with the number of duplicated code found) %maybe produce an example?


\section{Analysis}
%It was made an analysis to compare the refactoring tool with the others
%table information is available in GIT repository
%what my tool is different, what it is equal
\begin{table}[]
\centering
\caption{Data Structures}
\label{tab:my-table}
\begin{tabular}{c|c|c|c|c}
Name       & AST & PDG & Database & Others \\ \hline
Griswold   & X   & X   &          &        \\ \hline
HaRe       & X   &     &          &        \\ \hline
Rope       & X   &     & X        &        \\ \hline
Bicycle    & X   &     & X        &        \\ \hline
Pycharm Edu & X   &     & X        &        \\ \hline
Javascript &     &     &          & X
\end{tabular}
\end{table}

The Table~\ref{tab:my-table} summarizes the data structures of the analyzed refactoring tools.
It is clear that the AST of a program is an essential part of the refactoring
tool information with every refactoring tool having an AST to represent the program.
Regarding the PDG and Database it has mainly information about the def-use-relation
of the program. The PDG has also control flow information among others.

%HaRe only uses the AST as a source of information of the program. Thus, by not having
%the def-use-relation or a PDG it has less information to perform the refactoring operations.
%However, because HaRe is for the Haskell program language that is purely-functional
%programming language that extra information is not necessary to perform a good set of
%refactoring operations correctly.

Our implementation uses the same data structures, the AST and
def-use-relations. The def-use-relation is often represented as a database,
some refactoring tools annotate that information in the AST, %haskell v2
some tools extract the information from the AST itself when it is possible and
it is possible to extract that information from the PDG.\\


Some tools have more information about the program, either because they need that
information to perform the refactoring operation or because they need to prove that
the refactoring is correct.  %case of pycharm/python && Griswold
%Undoubtedly the main difference is in the objectives of each refactoring tool.
Other tools like the one build by Griswold focus on the correctness of the refactoring
operations.
Others, focus in offering refactoring operations for professional or advanced users.
However, the goal of our refactoring tool is to provide refactoring operations
designed for beginners. %FIXME suited aimed targeted
Therefore we are not interested in refactoring operations formerly proven %FIXME REWRITE
correct or provide refactoring operations only used in advanced and complex use cases. %FIXME where is the comma??
We intend to have simple, useful, and correct refactoring operations for the usual use cases a beginner would use.
With this set of scope we exclude macros usage, classes and other complex structures %TODO check this!
not used by beginners.

%TODO add I already used the refactoring tool to do a refactoring operation in
%the source code of the refactoring tool. However this is only applicable in the parts that are supported by this refactoring tool.
